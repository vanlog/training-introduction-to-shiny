---
title: "Simple Shiny App"
author: 
  - Andrea Melloncelli<br><br>andrea@vanlog.it
date: "10/5/2021"
output:
  slidy_presentation: 
    footer: "Copyright (c) 2021, Andrea Melloncelli"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

<style>
slides > slide {
  overflow-x: auto !important;
  overflow-y: auto !important;
}
code{
  background: #E4E5E7;
}
</style>

# Introduction to Shiny - Session 1

## 0.1: create a shiny Template app

Starting point: 0.0 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.0.zip))

Goal: creating a Hello World application.

1. Create a new `app.R` file
2. use the `shinyapp` snippet to create the first shiny application.
3. add `titlePanel("Hello World!")` in the `fluidPage` argument lists


## 0.2: add a user interface widget (no solution)

Starting point: 0.1 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.1.zip))

Goal: add an input and an output widget.

1. add a sliderInput: 
   ```r
   sliderInput(inputId = "n_bins",
               label = "Number of bins:",
               min = 0,
               max = 100,
               value = 50),
   ```
2. add a `plotOutput`. Verify that, however, the plot does not appear.
   ```r
   plotOutput("histogram")
   ```


## 0.3: Add the server logic

Goal: adding the logic to create the plot.

1. add `renderPlot` inside the server function:
   ```r
   output$histogram <- renderPlot({
     ggplot(df) +
       aes(x = values) +
       geom_histogram(bins = input$n_bins)
   })
   ```


## 0.4: Improve the appearance 

Starting point: 0.3 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.3.zip))

Goal: getting a nice look application.

1. improve plot: improve the appearance of the plot, with colour and transparency (server)
   ```r
   output$histogram <- renderPlot({
    ggplot(df) +
      aes(x = values) +
      geom_histogram(bins = input$n_bins,
                     fill = "lightblue",
                     color = "blue",
                     alpha = 0.7) +
      ggtitle("Values Histogram") +
      xlab("Values") +
      ylab("Count") +
      theme_bw()
   })
   ```
2. `sidebarLayout`: organize the object in a sidebar and a body (UI)
   ```r
   sidebarLayout(
    sidebarPanel(
      width = 3,
      sliderInput(inputId = "n_bins",
                  label = "Number of bins:",
                  min = 0,
                  max = 100,
                  value = 50)
    ),

    mainPanel(
      width = 9,
      plotOutput("histogram")
    )
   )
   ```


## 0.5: Understand what is happening 

Starting point: 0.4 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.4.zip))

Goal: generating log messages to understand reactivity.

Add `flog.info("some messages...")` inside your code and see when they are run. For example:

1. `flog.info("Loading data...")` in *global*
2. `flog.info("Running the server...")` in the `server` function
3. `flog.info("Rendering 'histogram' with %s bins...", input$n_bins)` inside `output$histogram <- renderPlot({`



## Reactive Variables (0.5)

The [Reactive Graph](https://mastering-shiny.org/reactive-graph.html) is the flux diagram to schematize a Shiny application.

This is the procedure to show the Reactive Graph of your app is (you need the `reactlog` package installed):

```r
reactlog::reactlog_enable()
runApp()
shiny::reactlogShow() 
```


## 0.6: Trigger reactivity or isolate

Starting point: 0.5 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.5.zip))

Goal: using `isolate`.

1. add [`textInput`](https://shiny.rstudio.com/gallery/widget-gallery.html) in the UI, to let the user choose the title of the plot
   ```r
      textInput(inputId = "plot_title",
                label = "Customize the plot title")
  ```

2. (exercise) use `output$plot_title` in `ggtitle` to set the title in the plot.

3. `isolate` the `output$plot_title` from triggering the reaction:

   ```r
   isolate(output$plot_title)
   ```

   NB: with `isolate` you are providing another reactive context to be triggered when the `output$plot_title` changes: in this case an isolated one, which will not trigger any reaction.
   
4. add an `actionButton` to trigger the reaction manually:
   ```r
   actionButton(inputId = "update_plot",
                label = "Update plot")
   ```


## 0.7: New data set

Starting point: 0.6 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.6.zip))

Goal: using a global procedure to load data at initialization time.

1. read a new dataset with `df <- read_csv("./data/marvel-vs-dc.csv")` in the *global*.
2. change the x axis of the histogram to `Minutes` to plot the timing statistics.
3. remove the `xlab` option which is now wrong.


## 0.8: select a variable

Starting point: 0.7 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.7.zip))

Goal: add a `selectInput` to the *UI*.

1. create a new variable in *global* with `df_colnames <- colnames(df)`
2. add a `selectInput` in the *UI*
3. add a requirement in the plot rendering: `req(is.numeric(df[[input$var_name]]))`. This in order to avoid to have an error if the user select a non numeric variable (non compliant with the x-axis of a Histogram)
4. visually split the sidebar in two parts with a horizontal line `tags$hr()`. Above the variables that update automatically the plot, below widgets that require the pressing of the button to update.


## 0.9: add a new plot (exercise)

Starting point: 0.8 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.8.zip))

Goal: adding a new plot (a density plot) below the other one.

1. add a new output plot `plotOutput` in the *UI* with `outputId = "density"`
2. add a new `renderPlot` in the *server* (advice: use `geom_density` in place of `geom_histogram`).
   NB: the density has `x = input$var_name`
3. group and colour two densities on the variable `Company` (advice: `aes_string(fill = "Company"))` )


## 0.10: colour the histogram by 'Company' (exercise)

Starting point: 0.9 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.9.zip))

Goal: modify a plot to make it consistent with the new object.

Working on 'histogram':

1. group and colour two stacked histograms on the variable `Company` (advice: `aes_string(fill = "Company"))` ). 


## 0.11: reactive dataset

Starting point: 0.10 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.10.zip))

Goal: using `reactiveVal` and `observe`.

A new *reactive variable* will be apart of the *reactive graph* and trigger the reloading of all objects depending on it. Here we need to create a subset of the dataset. Every time this subset will change all the derived objects will be updated.

1. create a `reactiveVal` to store a value of pre-filtered data frame. Set the initialization value to `NULL`. Inside the `server` function:
   ```r
   df_subset_rea <- reactiveVal(NULL)
   ```
2. create an `observe` that update that value with `df` (provide the observe with a `flog.info("updating 'df_subset_rea'...")` call):
   ```r
   observe({
    flog.info("updating 'df_subset_rea'...")

    df_subset_rea( df )  # assignment like: df_subset <- df
   })
   ```
3. use the `df_subset_rea` in the `renderPlot`s. The result is unchanged. In the next step you will be able to change the `df_subset_rea` according with some criteria.


## 0.12: filter on a Rate range (exercise)

Starting point: 0.11 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.11.zip))

Goal: try to add another input widget.

1. create [Slider Range](https://shiny.rstudio.com/gallery/widget-gallery.html) (`(inputId = "rate")`). NB: `rate` is a real number in range [0,10].
2. modify the `observe` to filter `df` on  `input$rate`.


## 0.13: use reactive in place of observe and reactiveVal

Starting point: 0.12 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.12.zip))

Goal: using `reactive`.

1. remove the definition of `df_subset_rea` as `reactiveVal`
2. substitute the `observe` with the new definition of `df_subset_rea` as `reactive`: the expression is the same except for that you must return the filtered dataframe and not re-assignig it to `df_subset_rea`.


## 0.14: count the number of times any reactive (exercise)

Starting point: 0.13 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.13.zip))

Goal: understanding state.

This is an example where the application need to keep track of a state (the count value) not present among inputs. In this cases `reactiveVal` or `reactiveValues` are mandatory,

Count the number of times any reactive has been modified.

1. create a counter as a `reactiveVal`
2. Observe all reactives and react increasing the counter by one
3. log with `flog.info(...)` the counter value.


## 0.15: eventReactive to plot Histogram only pressing the button (exercise)

Starting point: 0.14 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.14.zip))

Goal: using `eventReactive`.

Working on Histogram:

1. substitute 
   ```r
   output$histogram <- renderPlot({ ...EXPRESSION... })
   ```
   with 
   ```r
   histogram <- eventReactive(input$update_plot, { ...EXPRESSION... })
   ```
   Fix log message substituting "Rendering" with "Creating".
2. create again `output$histogram <- renderPlot({ histogram() })`. Add a log message: `flog.info("Rendering 'histogram'")`
3. Verify that the Histogram is created and updated only when you press the button. Verify that the Density plot has the old behaviour.


## 0.16: observeEvent to plot Density only pressing the button

Starting point: 0.15 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/0.15.zip))

Goal: using `observeEvent`.

Working on density plot:

1. create a reactiveValues `density <- reactiveValues(plot = NULL)`
2. substitute 
   ```r
   output$density <- renderPlot({ ...EXPRESSION... })
   ```
   with
   ```r
   observeEvent(input$update_plot, { ...EXPRESSION... })
   ```
   Fix the last command line changing the result from an assignation to the `reactiveValues`, `density`:
   ```r
   density$plot <- ggplot(df_subset_rea()) +
      aes_string(x = input$var_name, fill = "Company") +
      geom_density(bins = input$n_bins,
                   color = "blue",
                   alpha = 0.7) +
      ggtitle( paste("Distribution of", input$var_name) ) +
      ylab("Count") +
      theme_bw()
   ```
3. Fix log message substituting "Rendering" with "Creating".
4. create again `output$density <- renderPlot({ density$plot })`. Add a log message: `flog.info("Rendering 'density'")`

## Exercise 0.16.1: add a box plot 

Goal: add another plot.

Add a plot with a box plot of the distribution of `input$var_name` split on `Company`.


## Exercise 0.16.2: add a scatter plot

Goal: add another plot and insert a new variable selection.

Add a scatter plot of `input$var_name` over `input$var_name_2` (make this variable selectable by the *UI*)


## Exercise 0.16.3: decide what depens on button

Goal: improve the understanding of the reactive functions.

Play around with `isolate`, `reactive`, `eventReactive`, `observe` and `observeEvent` to drive the reactivity.


## Exercise 0.16.4: reactiveValues

Goal: using `reactiveValues`

Sometime you need to have a list of values. You can try subsituting a `reactiveVal` with a single element `reactiveValues` to understand how it works. 

Remember:

```r
# create the Values
my_values <- reactiveValues(my_data = NULL)

# update the value
my_values$my_data <- 0

# use value
my_values$my_data + 1
```


