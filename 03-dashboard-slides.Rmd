---
title: "Shiny Dashboards"
author: 
  - Andrea Melloncelli<br><br>andrea@vanlog.it
date: "10/5/2021"
output:
  slidy_presentation: 
    footer: "Copyright (c) 2021, Andrea Melloncelli"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

<style>
slides > slide {
  overflow-x: auto !important;
  overflow-y: auto !important;
}
code{
  background: #E4E5E7;
}
</style>



# Introduction to Shiny - Session 2


## 1.1: create a three file Shiny app

Starting point: 1.0 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.0.zip))

Goal: initialize a three file Shiny application.

1. Create a new folder and name it `dashboard`
2. Create a new file `server.R`:
   ```r
   server <- function(input, output, session) {

   }
   ```
2. Create a new file `ui.R`:
   ```r
   ui <- fluidPage(
     titlePanel("My Dashboard"),
   )
   ```
3. Verify that the application run and visualize the title.
4. Create an empty *global.R* file. It is not mandatory and executed as a script before launching the application.



## 1.2 Change to Shinydashboard

Starting point: 1.1 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.1.zip))

Goal: setup a shinydashboard.

We are going to work on the *UI*.

1. add `library(shinydashboard)` in *global.R*
2. Substitute a `fluidPage` with `dashboardPage`
3. Substitute a `titlePanel` with `dashboardHeader`
3. Add the mandatory *sidebar* and *body*:
   ```r
   ## Sidebar content ----
   dashboardSidebar(
    sidebarMenu(

    )
   ),

   ## Body content ----
   dashboardBody(

   )
   ```
   

## 1.3 Add the first Tab

Starting point: 1.2 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.2.zip))

Goal: adding the first tab

1. add a menu entry: 
   ```r
   menuItem(text = "Analysis", tabName = "analysis", icon = icon("fa-line-chart", lib = "font-awesome"))
   ```
2. Add a new tab content:
   ```r
    ## Analysis content --------------------------------------------------------
    tabItem(
      tabName = "analysis",
      h2("Analysis")
    )
   ```
3. Verify it works.


## 1.4 add a box

Starting point: 1.3 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.3.zip))

Goal: add a box 

1. add a box

   ```r
   box(
      title = "Movies",
   )
   ```
   
2. add `status = "primary"`
3. add `width = 6`
4. play around with `status = warning`, `width=12`, 


## 1.5 add a plot in the box (exercise)

Starting point: 1.4 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.4.zip))

Goal: adding a plot in the box

1. load the data in the global
2. add a `plotOutput` in the *UI* inside the box (as a unnamed argument) (`outputId = "scatter"`)
3. add a `renderPlot` in *server*, with `x = "Budget", y = "Gross_Worldwide"`
4. verify you can see the scatter plot
5. add a black/white theme and resize axis labels to 18
   ```r
      theme_bw() +
      theme(axis.title.x = element_text(size = 18),
            axis.title.y = element_text(size = 18))
   ```


## 1.6 compose the page

Starting point: 1.5 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.5.zip))

Goal: using box, tabBox and dataTable

1. add a `tabBox` 
   ```r
   tabBox(
        width = 6
      )
   ```
2. add a `tabPanel` with title "Movie info" inside the `tabBox`: 
   ```r
     tabPanel(
          title = "Movie info"
     )
     ```
3. add other two tabs: "Data Table", "Model"

4. set the same `height` in both boxes: `height = "500px"`

5. create a new box behind the two:
   ```r
   box(
     width = 12
   )
   ```
6. BE SURE to add `library(DT)` in *global*
7. put a `dataTableOutput("select_table")` in the third box.
8. remove the title to save space: `h2("Analysis"),`

## 1.7 Render and use the table

Starting point: 1.6 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.6.zip))

Goal: implement a nice datatable.

NB: in order to render a datatable you should use the `datatable` function. This function has arguments that you can fill with a list of obejcts.

1. render `select_table`
   ```r
   output$select_table <- renderDataTable({
    flog.info("Rendering select_table...")

    datatable(df)
  })
  ```

2. set datatable argument `filter` as `list(position = 'top', clear = FALSE)`, in order to activate a filter for each column

3. customize the serach box: 

   A. set datatable argument `options` as a list with a key named `search` with the following content:
   ```r
   list(
     regex = TRUE,            # use regular expressions
     caseInsensitive = FALSE, # upper case letter differ from lower case
     search = ''              # initial string to be searched
   )
   ```
   Look at the result.
   
4. add a filter sub-widget for each row. Set datatable argument `filter` with this list:
   ```r
   list(position = 'top'),
   ```

5. adapt the length of the table to the height of the page. 

   A. In `option` list create a new key:
   ```r
   pageLength = 3
   ```

   B. Verify that the page has now 3 rows.

7. You may have noticed that the `Company` variable is treated as a string. Actually it is a categorical variable. Changing the column type from *character* to *factor* will be enough to improve that datatable filter.

   A. in global mutate the column `Company` in a factor
      ```r
      Company = factor(Company)
      ```
   
   B. Verify that the column filter in datatable is now suitable to a categorical variable. (NB: you are modifying the global: be sure you shiny app is turned off and restarted)
   
8. Also integer are treated in a suitable way:

   C. (Exercise) You can do the same with the columns "Release", "Id" and "Metascore". Transform them from *numeric* to *integer* with the function `as.integer`
   
   D. Verify the changes in the application.
      

## 1.8 Better style for datatable

Starting point: 1.7 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.7.zip))

Goal: style datatable, server scoped non-reactive variables

In order to style a datatable you have to create a pipeline of style-transformation. In the `renderDatatable` take the result of `datatable` function and pipe into `formatStyle` functions.

Example:

```r
datatable(df) %>% 
  formatStyle(...)
```

1. Dealing with numbers, you can create in-line bar representing the greater of the amount. 

   A. For example with Rate (NB: the name of the column appears twice `"Rate"` and `df$Rate`)
      ```r
      # in-line bar
      formatStyle(
        'Rate',
        background = styleColorBar(df$Rate, 'steelblue'),
        backgroundSize = '90% 90%',
        backgroundRepeat = 'no-repeat',
        backgroundPosition = 'center'
      ) 
      ```
      
   B. (exercise) look at the result and do the same for "Metascore" and "Minutes"
   
2. (exercise) create in-line bars with the same scale.

   A. calculate the range of for vectors with the range function and name it `budget_range`:
      ```r
      budget_range <- range(df$Budget, df$Opening_Weekend_USA, df$Gross_USA, df$Gross_Worldwide)
      ```

   B. The first argument of `formatStyle` can be a vector of column names.
   
   C. The first argument of `styleColorBar` can be a range (two-value vector with min an max). Use `budget_range`
   
   D. create a in-line bar of the colour of dollars, for the money columns
   
      ```r
      dollar_bill_color <- "#85bb65"
      money_columns <- c("Budget", "Opening_Weekend_USA", "Gross_USA", "Gross_Worldwide")
      ```
   
3. add a style for the category variable "Company".

   A. add two colour representing the two categories at the beginning of *server* function
   
      ```r
      marvel_color <- 'lightblue'
      dc_color <- 'lightgreen'
      ```
      
   B. add this style for "Company"
   
      ```r
      # category coloured label
      formatStyle(
        'Company',
        transform = 'rotateX(45deg) rotateY(0deg) rotateZ(0deg)',
        backgroundColor = styleEqual(
          unique(df$Company), c(marvel_color, dc_color)
        )
      ) 
      ```
   
4. You can highlight the variable names used in the scatter plot, and also give specific colours to them

   A. define some color for x and y axis
   
      ```r
      x_colour <- "darkred"
      y_colour <- "darkgoldenrod"
      ```

   B. add a stile for the two columns
      ```r
      # highlight scatter variables
      formatStyle("Budget",  color = x_colour, fontWeight = 'bold') %>%
      formatStyle("Gross_Worldwide",  color = y_colour, fontWeight = 'bold')
      ```
   
   C. Color x and y labels in the scatter in the same way. NB: in order to do that x_colour and y_colour must be defined in *global* or in the *server* function (put them at the beginning of *server* function). Change the function `theme` in `renderPlot` in this way:
   
      ```r
      theme(axis.title.x = element_text(colour = x_colour,
                                        size = 18),
            axis.title.y = element_text(colour = y_colour,
                                        size = 18))
      ```

5. move all variables at the beginning of the server function, so that they can be used by all server obejcts and `budget_range` is calculated only once.

   ```r
   x_colour <- "darkred"
   y_colour <- "darkgoldenrod"
   marvel_color <- 'lightblue'
   dc_color <- 'lightgreen'
   dollar_bill_color <- "#85bb65"
   budget_range <- range(df$Budget, df$Opening_Weekend_USA, df$Gross_USA, df$Gross_Worldwide)
   ```
   


## 1.9 Filter scatter plot with datatable filters

Starting point: 1.8 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.8.zip))

Goal: reactive table filter

1. Gray out all points

   A. use this arguments in `geom_point` of `renderPlot` of the scatter plot
   
      ```r
      pch=21, fill="gray", size=2, colour="gray", stroke=1
      ```
      
2. Black colour to points in table:

   A. from datatable create a reactive with the subset of data filtered-in data table. When you use a filter the table will have less rows, you can get a dataframe with those rows. In server add a reactive:
   
      ```r
      data_subset <- reactive({
        flog.info("updating data_subset...")

        subset_indices <- input$select_table_rows_all       # rows on all pages (after being filtered)
        df[subset_indices,]
      })
      ```
      
   B. add another layer with a black points
   
      ```r
            + geom_point(data = data_subset(),
                 pch=21, fill="black", size=2, colour="black", stroke=1)
      ```

3. Filter out some values in Budget and see what happens on the plot



## 1.10 Visually connect table with plot

Starting point: 1.9 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.9.zip))

Goal: Interaction table-plot

1. Black colour to points in table:

   A. from datatable create a reactive with the subset of data visible in data table. In server add a reactive:
   
      ```r
      data_visible <- reactive({
        flog.info("updating data_visible...")

        visible_indices <- input$select_table_rows_current   # rows on the current page
        df[visible_indices,]
      })
      ```
      
   B. add another layer with a blue points
   
      ```r
      geom_point(data = data_visible(),
                 pch=21, fill="blue", size=4, colour="blue", stroke=1) +
      ```

3. Change table page, increase the number of visualized rows and see what happens.


## 1.11 Select from table

Starting point: 1.10 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.10.zip))

Goal: reactive selection from table

1. Black colour to points in table:

   A. from datatable create a reactive with the subset of data visible in data table. In server add a reactive:
   
      ```r
      data_selected <- reactive({
        flog.info("updating data_selected...")

        selected_indices <- input$select_table_rows_selected # selected rows (by a click)
        df[selected_indices,]
      })
      ```
      
   B. add another layer with a blue points
   
      ```r
      geom_point(data = data_selected(),
                 pch=21, fill=NA, size=6, colour="red", stroke=1) +
      ```

3. Click on a row to select or de-select a row. Multiple selection is allowed.




## 1.12 Get info from the plot

Starting point: 1.11 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.11.zip))

Goal: reactive mouse hovering selection

1. add the `hover` in the `plotOutput` of scatter in the *UI*
      ```r
            plotOutput("scatter",
                       hover = "scatter_hover")
      ```
      
2. add the `uiOutput` in the tabPanel "Movie info"

      ```r
            tabPanel(
              title = "Movie info",
              uiOutput("movie_info")     # new
            ),
      ```
      
3. in *server* fill the uiOutput with the hovering information:

      ```r
      output$movie_info <- renderUI({
        point <- input$scatter_hover
        flog.info("Point hover is %s", point$Original_Title)

        if (is.null(point)) {
          tags$p("Please select a movie from the plot")
        } else {
          tagList(
            p("Budget: ", round(point$x,2)) ,
            p("Gross_Worldwide: ", round(point$y,2))
          )
        }
      })
      ```
    
## 1.12.1 prepare to use multiple tabs

Goal: prepare to use multiple tabs

1. put the only `tabItem` into a `tabItems` function.



## 1.13 Load a new dataset

Starting point: 1.12.1 ([download zip](https://github.com/vanlog/training-introduction-to-shiny/archive/refs/heads/1.12.1.zip))

Goal: loading a file

1. (exercise) create another tab called "load_data"

2. insert a [file-upload widget](https://shiny.rstudio.com/gallery/file-upload.html) inside a box:

      ```r
      ## load data content -------------------------------------------------------
      tabItem(
        tabName = "load_data",
        box(
          title = "Upload data",
          status = "primary",
          width = 6,
          fileInput(
            "data_file",
            "Choose CSV File",
            multiple = FALSE,
            accept = c("text/csv",
                       "text/comma-separated-values,text/plain",
                       ".csv")),
          )
      ),
      ```

3. comment out the reading of df in global

4. create a reactive dataset to read the uploaded file

  ```r
  dataset <- eventReactive(input$data_file, {
    # input$dataset will be NULL initially. And so the dataset() reactive
    req(input$data_file)

    tryCatch(
      {
        df <- read_csv(input$data_file$datapath) %>%
          mutate(Company = factor(Company),
                 Release = as.integer(Release),
                 Id = as.integer(Id),
                 Metascore = as.integer(Metascore))
      },
      error = function(e) {
        # return a safeError if a parsing error occurs
        stop(safeError(e))
      }
    )

    return(df)
  })
  ```
    
5. substitute all occorrencies of `df` with `dataset()`

6. you will realize that now also the `budget_range` have to be a reactive. Do it and substitute all occurencies with `budget_range()`.

7. (exercise) add a preview of the dataset in the first tab.
  




